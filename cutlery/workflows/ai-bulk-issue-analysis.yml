name: AI Bulk Issue Analysis

on:
  pull_request:
    types: [ closed ]
    branches: [ main ]

jobs:
  analyze-all-issues:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    
    permissions:
      issues: write
      contents: read
    
    steps:
      - name: Checkout current repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js for repomix
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup Python for AI analysis
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install repomix
        run: |
          npm install -g repomix
          echo "Repomix installed successfully"
          repomix --version
      
      - name: Generate repomix output
        run: |
          echo "Reading configuration from triage.config.json..."
          REPO_URL=$(jq -r '.repository.url' triage.config.json)
          REPOMIX_OUTPUT=$(jq -r '.repomix.output_path' triage.config.json)
          echo "Repository URL: $REPO_URL"
          echo "Repomix output path: $REPOMIX_OUTPUT"
          
          echo "Running repomix on repository using remote..."
          repomix --remote "$REPO_URL" --output "$REPOMIX_OUTPUT"
          echo "Repomix output generated successfully"
          ls -la "$REPOMIX_OUTPUT"
      
      - name: Clone AI-Issue-Triage repository
        uses: actions/checkout@v4
        with:
          repository: tanwigeetika1618/AI-Issue-Triage
          ref: main
          path: ai-triage
          fetch-depth: 1
      
      - name: Install Python dependencies for AI triage
        run: |
          cd ai-triage
          
          echo "Installing Python dependencies..."
          if pip install -r requirements.txt; then
          echo "Python dependencies installed successfully"
          else
            echo "ERROR: Failed to install Python dependencies"
            echo "Requirements file contents:"
            cat requirements.txt
            exit 1
          fi
          
          # Verify critical packages are installed
          python3 -c "import pytector; print('âœ“ pytector installed')" || echo "âš ï¸ pytector not available"
          python3 -c "import google.genai; print('âœ“ google-genai installed')" || echo "âš ï¸ google-genai not available"
      
      - name: Fetch all open issues
        id: fetch-issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get all open issues (oldest first for duplicate detection)
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100,
              sort: 'created',
              direction: 'asc'  // Oldest first
            });
            
            // Filter out pull requests
            const actualIssues = issues.filter(issue => !issue.pull_request);
            console.log(`Found ${actualIssues.length} open issues (processing oldest â†’ newest)`);
            
            // Save issue numbers to file for bash processing
            const issueNumbers = actualIssues.map(i => i.number);
            fs.writeFileSync('issue_numbers.txt', issueNumbers.join('\n') + '\n');
            
            // Also save full issue data for duplicate detection
            const issueData = actualIssues.map(i => ({
              number: i.number,
              title: i.title,
              body: i.body || '',
              html_url: i.html_url,
              labels: i.labels.map(l => typeof l === 'string' ? l : l.name)
            }));
            fs.writeFileSync('all_issues.json', JSON.stringify(issueData, null, 2));
            
            console.log(`Saved ${issueNumbers.length} issue numbers to issue_numbers.txt`);
            console.log(`Issue numbers: ${issueNumbers.join(', ')}`);
      
      - name: Process all issues
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          
          # Read configuration
          REPOMIX_OUTPUT=$(jq -r '.repomix.output_path' triage.config.json)
          CUSTOM_PROMPT_PATH=$(jq -r '.analysis.custom_prompt_path // ""' triage.config.json)
          GEMINI_MODEL=$(jq -r '.gemini.model // ""' triage.config.json)
          
          echo "Using repomix output: $REPOMIX_OUTPUT"
          if [ -n "$CUSTOM_PROMPT_PATH" ] && [ "$CUSTOM_PROMPT_PATH" != "null" ]; then
            echo "Using custom prompt: $CUSTOM_PROMPT_PATH"
          fi
          if [ -n "$GEMINI_MODEL" ] && [ "$GEMINI_MODEL" != "null" ]; then
            echo "Using Gemini model: $GEMINI_MODEL"
          else
            echo "Using default Gemini model: gemini-2.0-flash-001"
          fi
          
          # Verify required files exist
          echo ""
          echo "Verifying required files..."
          if [ ! -f "$REPOMIX_OUTPUT" ]; then
            echo "ERROR: Repomix output file not found: $REPOMIX_OUTPUT"
            ls -la
            exit 1
          fi
          echo "âœ“ Repomix output exists: $REPOMIX_OUTPUT"
          
          if [ ! -f "issue_numbers.txt" ]; then
            echo "ERROR: issue_numbers.txt not found"
            ls -la
            exit 1
          fi
          echo "âœ“ Issue numbers file exists"
          
          ISSUE_COUNT_TOTAL=$(wc -l < issue_numbers.txt | tr -d ' ')
          if [ "$ISSUE_COUNT_TOTAL" -eq 0 ]; then
            echo "No issues to process. Exiting successfully."
            exit 0
          fi
          echo "âœ“ Found $ISSUE_COUNT_TOTAL issues to process"
          echo "Issue numbers from file: $(cat issue_numbers.txt | tr '\n' ', ' | sed 's/,$//')"
          
          if [ ! -f "all_issues.json" ]; then
            echo "ERROR: all_issues.json not found"
            exit 1
          fi
          echo "âœ“ Issue data file exists"
          
          # Copy repomix output to ai-triage directory
          echo ""
          echo "Copying repomix output to ai-triage directory..."
          cp "$REPOMIX_OUTPUT" ai-triage/
          echo "âœ“ Repomix output copied"
          
          # Initialize analyzed issues file (for duplicate detection)
          echo "[]" > analyzed_issues.json
          echo "âœ“ Initialized analyzed_issues.json"
          
          # Process each issue
          echo ""
          echo "================================================================"
          echo "Starting bulk analysis of $ISSUE_COUNT_TOTAL issues..."
          echo "================================================================"
          
          ISSUE_COUNT=0
          while IFS= read -r ISSUE_NUMBER; do
            ISSUE_COUNT=$((ISSUE_COUNT + 1))
            echo ""
            echo "================================================================"
            echo "Processing Issue #$ISSUE_NUMBER ($ISSUE_COUNT of $(wc -l < issue_numbers.txt))"
            echo "================================================================"
            
            # Get issue details
            ISSUE_DATA=$(jq -r ".[] | select(.number == $ISSUE_NUMBER)" all_issues.json)
            ISSUE_TITLE=$(echo "$ISSUE_DATA" | jq -r '.title')
            ISSUE_BODY=$(echo "$ISSUE_DATA" | jq -r '.body // ""')
            
            echo "Title: $ISSUE_TITLE"
            
            # Check if issue has "Bypass Prompt Injection Check" label
            ISSUE_LABELS=$(echo "$ISSUE_DATA" | jq -r '.labels[]' | tr '\n' ',' | sed 's/,$//')
            echo "Issue labels: $ISSUE_LABELS"
            
            BYPASS_INJECTION="false"
            if echo "$ISSUE_LABELS" | grep -q "Bypass Prompt Injection Check"; then
              BYPASS_INJECTION="true"
              echo "âš¡ Bypass Prompt Injection Check label detected - skipping security check"
            fi
            
            # ==================== PROMPT INJECTION CHECK ====================
            echo ""
            echo ">>> Step 1: Checking for prompt injection..."
            cd ai-triage
            
            HAS_INJECTION="false"
            RISK_LEVEL="safe"
            
            if [ "$BYPASS_INJECTION" = "true" ]; then
              echo "Prompt injection check bypassed by user label"
              HAS_INJECTION="false"
              RISK_LEVEL="safe"
            elif [ -f "utils/security/prompt_injection.py" ]; then
              if python3 -m utils.security.prompt_injection "$ISSUE_TITLE" "$ISSUE_BODY" > "prompt_injection_${ISSUE_NUMBER}.json" 2>"prompt_injection_debug_${ISSUE_NUMBER}.log"; then
                echo "Prompt injection detection completed"
              else
                echo "WARNING: Prompt injection detection failed, trying debug mode..."
                python3 -m utils.security.prompt_injection "$ISSUE_TITLE" "$ISSUE_BODY" --debug > "prompt_injection_${ISSUE_NUMBER}.json" 2>&1 || {
                  echo '{"has_prompt_injection": false, "risk_level": "safe", "error": "detection_failed"}' > "prompt_injection_${ISSUE_NUMBER}.json"
                }
              fi
              
              # Parse results
              if [ -f "prompt_injection_${ISSUE_NUMBER}.json" ]; then
                HAS_INJECTION=$(jq -r '.has_prompt_injection // false' "prompt_injection_${ISSUE_NUMBER}.json")
                RISK_LEVEL=$(jq -r '.risk_level // "safe"' "prompt_injection_${ISSUE_NUMBER}.json")
                echo "Prompt injection detected: $HAS_INJECTION (Risk: $RISK_LEVEL)"
              fi
            else
              echo "Prompt injection detection not available"
            fi
            
            cd ..
            
            # Post prompt injection report (skip if bypassed)
            if [ "$BYPASS_INJECTION" != "true" ]; then
              RISK_EMOJI="âœ…"
              case "$RISK_LEVEL" in
                critical) RISK_EMOJI="ðŸš¨" ;;
                high) RISK_EMOJI="âš ï¸" ;;
                medium) RISK_EMOJI="âš¡" ;;
                low) RISK_EMOJI="â„¹ï¸" ;;
              esac
              
              INJECTION_COMMENT="${RISK_EMOJI} **Prompt Injection Analysis Report**\n\n**Risk Level:** $(echo $RISK_LEVEL | tr '[:lower:]' '[:upper:]')\n\n"
              
              if [ "$RISK_LEVEL" = "safe" ]; then
                INJECTION_COMMENT="${INJECTION_COMMENT}This issue has been analyzed and appears to be safe. No prompt injection patterns were detected.\n\n"
                INJECTION_COMMENT="${INJECTION_COMMENT}**Analysis Result:** âœ… SAFE\n\n"
              elif [ "$RISK_LEVEL" = "critical" ] || [ "$RISK_LEVEL" = "high" ]; then
                INJECTION_COMMENT="${INJECTION_COMMENT}**âš ï¸ SECURITY ALERT**\n\nThis issue contains content that appears to be a prompt injection attempt. For security reasons, this issue will not be processed by the AI analysis system.\n\n"
                
                # Add security labels with color and description
                gh label create "Prompt injection blocked" --description "AI-generated: Issue flagged for potential prompt injection - high risk" --color "d73a4a" --force || true
                gh issue edit "$ISSUE_NUMBER" --add-label "Prompt injection blocked" || echo "Failed to add labels"
              else
                INJECTION_COMMENT="${INJECTION_COMMENT}This issue contains content that may contain prompt injection patterns, but the risk level is manageable. Processing will continue with caution.\n\n"
                
                # Add warning label with color and description
                gh label create "Prompt injection warning" --description "AI-generated: Issue may contain prompt injection patterns - low risk" --color "fbca04" --force || true
                gh issue edit "$ISSUE_NUMBER" --add-label "Prompt injection warning" || echo "Failed to add labels"
              fi
              
              INJECTION_COMMENT="${INJECTION_COMMENT}---\n*This security check is performed automatically to protect the AI analysis system.*"
              
              # Post comment (write to file first to avoid escaping issues)
              printf "%b" "$INJECTION_COMMENT" > "injection_comment_${ISSUE_NUMBER}.md"
              gh issue comment "$ISSUE_NUMBER" --body-file "injection_comment_${ISSUE_NUMBER}.md" || echo "Failed to post injection comment"
            fi
            
            # Skip analysis for high/critical risk
            if [ "$RISK_LEVEL" = "critical" ] || [ "$RISK_LEVEL" = "high" ]; then
              echo "SECURITY: Skipping analysis for issue #$ISSUE_NUMBER due to $RISK_LEVEL risk"
              continue
            fi
            
            # ==================== DUPLICATE CHECK ====================
            echo ""
            echo ">>> Step 2: Checking for duplicates..."
            
            # Create JSON file with previously analyzed issues
            ANALYZED_COUNT=$(jq 'length' analyzed_issues.json)
            echo "Comparing against $ANALYZED_COUNT previously analyzed issues..."
            
            IS_DUPLICATE="false"
            if [ "$ANALYZED_COUNT" -gt 0 ]; then
              # Create issues list for duplicate check
              jq '[.[] | {issue_id: .number, title: .title, description: .body, status: "open", url: .html_url}]' analyzed_issues.json > ai-triage/existing_issues_analyzed.json
              
              cd ai-triage
              # Run duplicate check twice: once for JSON (to check if duplicate), once for nice text output
              if python -m cli.duplicate_check --title "$ISSUE_TITLE" --description "$ISSUE_BODY" --issues existing_issues_analyzed.json --output json > "duplicate_result_${ISSUE_NUMBER}.json" 2>&1; then
                # Validate JSON before parsing
                if jq empty "duplicate_result_${ISSUE_NUMBER}.json" 2>/dev/null; then
                  IS_DUPLICATE=$(jq -r '.is_duplicate // false' "duplicate_result_${ISSUE_NUMBER}.json")
                  echo "Duplicate check result: $IS_DUPLICATE"
                  
                  if [ "$IS_DUPLICATE" = "true" ]; then
                    DUPLICATE_OF=$(jq -r '.duplicate_of.issue_id' "duplicate_result_${ISSUE_NUMBER}.json")
                    
                    echo "Issue #$ISSUE_NUMBER is a DUPLICATE of issue #$DUPLICATE_OF"
                    
                    # Add duplicate label with color and description
                    cd ..
                    gh label create "Duplicate" --description "AI-generated: This issue appears to be a duplicate of another issue" --color "cfd3d7" --force || true
                    gh issue edit "$ISSUE_NUMBER" --add-label "Duplicate" || echo "Failed to add duplicate label"
                    
                    # Get formatted duplicate comment from CLI tool
                    cd ai-triage
                    python -m cli.duplicate_check --title "$ISSUE_TITLE" --description "$ISSUE_BODY" --issues existing_issues_analyzed.json > "duplicate_text_${ISSUE_NUMBER}.txt" 2>&1
                    cd ..
                    
                    # Post the formatted duplicate comment
                    DUP_COMMENT=$(cat "ai-triage/duplicate_text_${ISSUE_NUMBER}.txt")
                    DUP_COMMENT="${DUP_COMMENT}\n\n---\n*This check was performed during bulk analysis.*"
                    
                    # Post comment (write to file first to avoid escaping issues)
                    printf "%b" "$DUP_COMMENT" > "duplicate_comment_${ISSUE_NUMBER}.md"
                    gh issue comment "$ISSUE_NUMBER" --body-file "duplicate_comment_${ISSUE_NUMBER}.md" || echo "Failed to post duplicate comment"
                    
                    echo "Skipping full AI analysis for duplicate issue"
                    continue
                  fi
                else
                  echo "WARNING: duplicate_result_${ISSUE_NUMBER}.json contains invalid JSON"
                  echo "Contents of duplicate_result_${ISSUE_NUMBER}.json:"
                  cat "duplicate_result_${ISSUE_NUMBER}.json"
                  IS_DUPLICATE="false"
                fi
              else
                echo "Duplicate detection failed, assuming not duplicate"
                IS_DUPLICATE="false"
              fi
              cd ..
            else
              echo "No previously analyzed issues to compare against (first issue)"
            fi
            
            # ==================== AI ANALYSIS ====================
            echo ""
            echo ">>> Step 3: Running AI analysis..."
            
            # Add this issue to analyzed list
            jq --arg num "$ISSUE_NUMBER" --arg title "$ISSUE_TITLE" --arg body "$ISSUE_BODY" --arg url "$(echo "$ISSUE_DATA" | jq -r '.html_url')" \
              '. += [{number: ($num | tonumber), title: $title, body: $body, html_url: $url}]' \
              analyzed_issues.json > analyzed_issues_tmp.json
            mv analyzed_issues_tmp.json analyzed_issues.json
            echo "Added issue #$ISSUE_NUMBER to analyzed list (total: $(jq 'length' analyzed_issues.json))"
            
            cd ai-triage
            
            # Build CLI arguments
            CLI_ARGS="--title \"$ISSUE_TITLE\" --description \"$ISSUE_BODY\" --source-path \"$(basename $REPOMIX_OUTPUT)\""
            
            if [ -n "$CUSTOM_PROMPT_PATH" ] && [ "$CUSTOM_PROMPT_PATH" != "null" ] && [ -f "../$CUSTOM_PROMPT_PATH" ]; then
              CLI_ARGS="$CLI_ARGS --custom-prompt \"../$CUSTOM_PROMPT_PATH\""
            fi
            
            if [ -n "$GEMINI_MODEL" ] && [ "$GEMINI_MODEL" != "null" ]; then
              CLI_ARGS="$CLI_ARGS --model \"$GEMINI_MODEL\""
            fi
            
            # Run analysis (JSON format)
            echo "Running analysis..."
            eval "python -m cli.analyze $CLI_ARGS --format json --output analysis_result_${ISSUE_NUMBER}.json --quiet" || {
              echo "ERROR: Analysis failed for issue #$ISSUE_NUMBER"
              cd ..
              continue
            }
            
            # Run analysis (text format)
            eval "python -m cli.analyze $CLI_ARGS --format text --output analysis_result_${ISSUE_NUMBER}.txt --quiet" || {
              echo "ERROR: Text analysis failed for issue #$ISSUE_NUMBER"
              cd ..
              continue
            }
            
            echo "Analysis completed successfully"
            
            # Read analysis results
            ANALYSIS_TEXT=$(cat "analysis_result_${ISSUE_NUMBER}.txt")
            
            cd ..
            
            # Post analysis comment (already beautifully formatted, no wrapper needed)
            printf "%s" "$ANALYSIS_TEXT" > "analysis_comment_${ISSUE_NUMBER}.md"
            gh issue comment "$ISSUE_NUMBER" --body-file "analysis_comment_${ISSUE_NUMBER}.md" || echo "Failed to post analysis comment"
            
            # Update labels
            if [ -f "ai-triage/analysis_result_${ISSUE_NUMBER}.json" ]; then
              ISSUE_TYPE=$(jq -r '.issue_type // ""' "ai-triage/analysis_result_${ISSUE_NUMBER}.json")
              SEVERITY=$(jq -r '.severity // ""' "ai-triage/analysis_result_${ISSUE_NUMBER}.json")
              
              # Get current labels and remove old type:* and severity:* labels
              echo "Fetching current labels for issue #$ISSUE_NUMBER..."
              CURRENT_LABELS=$(gh issue view "$ISSUE_NUMBER" --json labels --jq '.labels[].name' | tr '\n' ',' | sed 's/,$//')
              echo "Current labels: $CURRENT_LABELS"
              
              # Remove old type:* and severity:* labels and old type labels
              if [ -n "$CURRENT_LABELS" ]; then
                for label in $(echo "$CURRENT_LABELS" | tr ',' '\n'); do
                  if [[ "$label" == type:* ]] || [[ "$label" == severity:* ]] || \
                     [[ "$label" == "Type : "* ]] || [[ "$label" == "Severity : "* ]] || \
                     [[ "$label" == "Bug" ]] || [[ "$label" == "Enhancement" ]] || \
                     [[ "$label" == "Feature request" ]] || [[ "$label" == "Documentation" ]] || \
                     [[ "$label" == "Question" ]] || [[ "$label" == "Task" ]] || \
                     [[ "$label" == "Critical" ]] || [[ "$label" == "High" ]] || \
                     [[ "$label" == "Medium" ]] || [[ "$label" == "Low" ]]; then
                    echo "Removing old label: $label"
                    gh issue edit "$ISSUE_NUMBER" --remove-label "$label" || echo "Failed to remove label: $label"
                  fi
                done
              fi
              
              # Add new labels with colors and descriptions
              LABELS_TO_ADD=""
              
              # Create and add type label
              if [ -n "$ISSUE_TYPE" ] && [ "$ISSUE_TYPE" != "null" ]; then
                TYPE_VALUE="$(echo "$ISSUE_TYPE" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')"
                TYPE_LABEL="Type : $TYPE_VALUE"
                case "$TYPE_VALUE" in
                  Bug) TYPE_COLOR="d73a4a" ;;
                  Enhancement) TYPE_COLOR="a2eeef" ;;
                  "Feature request") TYPE_COLOR="0e8a16" ;;
                  Documentation) TYPE_COLOR="0075ca" ;;
                  Question) TYPE_COLOR="d876e3" ;;
                  Task) TYPE_COLOR="fbca04" ;;
                  *) TYPE_COLOR="ededed" ;;
                esac
                gh label create "$TYPE_LABEL" --description "AI-generated: Issue type identified as ${ISSUE_TYPE,,}" --color "$TYPE_COLOR" --force || true
                LABELS_TO_ADD="$TYPE_LABEL"
              fi
              
              # Create and add severity label
              if [ -n "$SEVERITY" ] && [ "$SEVERITY" != "null" ]; then
                SEVERITY_VALUE="$(echo "$SEVERITY" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')"
                SEVERITY_LABEL="Severity : $SEVERITY_VALUE"
                case "$SEVERITY_VALUE" in
                  Critical) SEVERITY_COLOR="b60205" ;;
                  High) SEVERITY_COLOR="d93f0b" ;;
                  Medium) SEVERITY_COLOR="fbca04" ;;
                  Low) SEVERITY_COLOR="0e8a16" ;;
                  *) SEVERITY_COLOR="ededed" ;;
                esac
                gh label create "$SEVERITY_LABEL" --description "AI-generated: Severity level assessed as ${SEVERITY,,}" --color "$SEVERITY_COLOR" --force || true
                if [ -n "$LABELS_TO_ADD" ]; then
                  LABELS_TO_ADD="${LABELS_TO_ADD},$SEVERITY_LABEL"
                else
                  LABELS_TO_ADD="$SEVERITY_LABEL"
                fi
              fi
              
              if [ -n "$LABELS_TO_ADD" ]; then
                echo "Adding new labels: $LABELS_TO_ADD"
                gh issue edit "$ISSUE_NUMBER" --add-label "$LABELS_TO_ADD" || echo "Failed to update labels"
              else
                echo "No additional labels to add"
              fi
            fi
            
            echo "Issue #$ISSUE_NUMBER processed successfully"
            
          done < issue_numbers.txt
          
          echo ""
          echo "================================================================"
          echo "Bulk analysis completed! Processed $ISSUE_COUNT issues."
          echo "================================================================"
